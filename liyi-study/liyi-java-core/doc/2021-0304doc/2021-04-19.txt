学习进度

E:\学习-尚硅谷\1.尚硅谷全套JAVA教程--基础阶段（73.36GB）\
1.尚硅谷宋红康Java核心基础_好评如潮\Java基础全套视频教程\day16_异常处理13


疑难点：
1.abstract关键字的使用
1.1.①abstract可以用来修饰类、结构、方法，
    ②不能用来修饰属性、构造器等结构
    ③不能用来修饰私有方法、静态方法、final的方法、final的类

1.2.abstract修饰类：抽象类
    ①此类不能实例化
    ②抽象类中一定有构造器，便于子类实例化调用（涉及：子类实例化的全过程）
    ③开发中，都会抽象类的子类，让子类对象实例化，完成相关的操作

1.3.abstract修饰方法：抽象方法
    ①抽象方法只有方法的声明，没有方法体
    ②包含抽象方法的类，一定是一个抽象类；反之，抽象类中不一定有抽象方法
    ③若子类重写了父类中所有的抽象方法，则此子类方可实例化；
     若子类没有重写父类所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰

2.接口的使用
2.1.接口使用interface来定义

2.2.java中，接口和类是并列的两个结构

2.2.如何定义接口：定义接口中的成员
    ①jdk7及以前：只能定义全局常量和抽象方法
    >全局常量：public static final的，但是书写时，可以省略不写
    >抽象方法：public abstract的
    ②jdk8:除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法

2.3.接口中不能定义构造器，意味着接口不能实例化

2.4.java开发中，接口通过类去实现(implements)的方式来使用;
    如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化；
    如果实现类没有覆盖接口中的所有抽象方法，则此实现类仍为一个抽象类。

2.5.java类可以实现多个接口===》弥补了java类单继承性的局限性

2.6.接口和接口之间可以继承，而且可以多继承

2.7.
    ①接口中的静态方法只能接口来调用
    ②通过实现类的对象，可以调用接口中的默认方法；
     如果实现类重写了接口中的默认方法，调用是，仍然调用的是重写以后的方法
    ③如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，
     那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的方法===》类优先原则
    ④如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，
     那么在实现类没有重写此方法的情况下，报错===》接口冲突，
     就需要我们必须在实现类中重写此方法

3.局部内部类和成员内部类
3.1.成员内部类：
             一方面，作为外部类的成员：
             ①调用外部类的结构
             ②可以被static修饰
             ③可以被4中不同的权限修饰

             另一方面，作为一个类：
             ①类内可以定义属性、方法、构造器等
             ②可以被final修饰，表示此类不能被继承。不使用final，就可以被继承
             ③可以被abstract修饰

4.异常处理
4.1.try catch finally结构
   ①finally是可选的
   ②使用try将可能出现异常的代码包装起来，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，
     去catch中进行匹配
   ③一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前try-catch
     结构(在没有写finally的情况)，继续执行其后的代码
   ④catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓；
     如果catch中的异常类型满足子父类关系，则子类一定要声明在父类的上面。否则，报错
   ⑤finally中声明的是一定会执行的代码，即使catch中又出现异常了，try中有return语句，
     catch中有return语句等情况
   ⑥在try结构中声明的变量，在出了try结构以后，就不能再被调用
   ⑦try-catch-finally结构可以嵌套